{
  "_args": [
    [
      {
        "raw": "atom-utils@>=0.9.2",
        "scope": null,
        "escapedName": "atom-utils",
        "name": "atom-utils",
        "rawSpec": ">=0.9.2",
        "spec": ">=0.9.2",
        "type": "range"
      },
      "/tmp/d-11748-12986-1yooisz.axx7096bt9/package.tgz"
    ]
  ],
  "_from": "atom-utils@>=0.9.2",
  "_id": "atom-utils@0.9.2",
  "_inCache": true,
  "_location": "/minimap/atom-utils",
  "_nodeVersion": "1.2.0",
  "_npmUser": {
    "name": "abe33",
    "email": "cedric.nehemie@gmail.com"
  },
  "_npmVersion": "2.5.1",
  "_phantomChildren": {},
  "_requested": {
    "raw": "atom-utils@>=0.9.2",
    "scope": null,
    "escapedName": "atom-utils",
    "name": "atom-utils",
    "rawSpec": ">=0.9.2",
    "spec": ">=0.9.2",
    "type": "range"
  },
  "_requiredBy": [
    "/minimap"
  ],
  "_resolved": "https://registry.npmjs.org/atom-utils/-/atom-utils-0.9.2.tgz",
  "_shasum": "de9c759df98c119a685f709736336df8703a623e",
  "_shrinkwrap": null,
  "_spec": "atom-utils@>=0.9.2",
  "_where": "/tmp/d-11748-12986-1yooisz.axx7096bt9/package.tgz",
  "author": {
    "name": "Cédric Néhémie",
    "email": "cedric.nehemie@gmail.com"
  },
  "bugs": {
    "url": "https://github.com/abe33/atom-utils/issues"
  },
  "dependencies": {
    "event-kit": "^1",
    "grim": "^2",
    "mixto": "^1"
  },
  "description": "A bunch of general purpose utilities for Atom packages",
  "devDependencies": {
    "grunt": "~0.4.1",
    "grunt-cli": "~0.1.8",
    "grunt-coffeelint": "0.0.6",
    "grunt-contrib-coffee": "~0.7.0",
    "grunt-contrib-watch": "~0.5.3",
    "grunt-shell": "~0.2.2",
    "jasmine-focused": "1.x",
    "promise": "*"
  },
  "directories": {},
  "dist": {
    "shasum": "de9c759df98c119a685f709736336df8703a623e",
    "tarball": "https://registry.npmjs.org/atom-utils/-/atom-utils-0.9.2.tgz"
  },
  "gitHead": "5d63f7abec3141be43e494ede28e8927e9b7b4df",
  "homepage": "https://github.com/abe33/atom-utils",
  "keywords": [
    "atom",
    "utils"
  ],
  "license": "MIT",
  "main": "lib/atom-utils.js",
  "maintainers": [
    {
      "name": "abe33",
      "email": "cedric.nehemie@gmail.com"
    }
  ],
  "name": "atom-utils",
  "optionalDependencies": {},
  "readme": "## atom-utils\n\n[![Build Status](https://travis-ci.org/abe33/atom-utils.svg?branch=master)](https://travis-ci.org/abe33/atom-utils)\n\nA bunch of general purpose utilities for Atom packages.\n\n### requirePackages(packageNames...)\n\nReturns a promise that is only resolved when all the requested packages have been activated.\n\n```coffee\n{requirePackages} = require 'atom-utils'\n\nrequirePackages('tree-view', 'find-and-replace', 'snippets')\n.then ([treeView, findAndReplace, snippets]) ->\n  # Do something with the required packages\n```\n\n### registerOrUpdateElement(elementName, prototype)\n\nRegisters or updates a custom element whose name is `elementName`.\n\n```coffee\n{registerOrUpdateElement} = require 'atom-utils'\n\nclass MyElement\n  createdCallback: ->\n    console.log 'element created'\n\nregisterOrUpdateElement('my-element', MyElement.prototype)\n```\n\nThe update is performed by copying the properties from the passed-in prototype in the registered element prototype. As a node's callback methods can't be overriden once the element have been registered, a generic version is created that will invoke the concrete callback when called, that way even the node's callback methods can be updated.\n\n### Ancestors (previously AncestorsMethods)\n\nA mixin that provides jQuery a like method to retrieve a node's parents:\n\n```coffee\n{Ancestors} = require 'atom-utils'\n\nclass DummyNode extends HTMLElement\n  Ancestors.includeInto(this)\n\n  attachedCallback: ->\n    # Returns all the ancestors to the html element\n    parents = @parents()\n\n    # Returns all the ancestors that matches the selector\n    filteredParents = @parents('selector')\n\n# It creates the custom element and register it as the `dummy-node` tag.\nDummyNode = document.registerElement 'dummy-node', prototype: DummyNode.prototype\n```\n\n#### ::parents(selector)\n\nCan be called with or without the selector argument.\n\nIf called without argument, the method will return every parents of the current\nnode.\n\nIf called with an argument, the method will return only the parent elements that match the passed-in selector.\n\nParents in the returned array are sorted by their distance from the node.\n\n#### ::queryParentSelectorAll(selector)\n\nAn alias of `::parents` except it throw an error if called without a selector.\n\n#### ::queryParentSelector(selector)\n\nReturns only the first parent element that matches the passed-in selector.\n\nThrows an error when called without a selector.\n\n### ::eachParent(iterator)\n\nIterates over each parent the node and calls `iterator` with the current parent node.\n\n### DisposableEvents\n\nA mixin that provides a `addDisposableEventListener` method that registers an event listener on an element and returns a `Disposable` to unregister it:\n\n```coffee\n{DisposableEvents} = require 'atom-utils'\n{CompositeDisposable} = require 'event-kit'\n\nclass DummyNode extends HTMLElement\n  DisposableEvents.includeInto(this)\n\n  createdCallback: ->\n    @subscriptions = new CompositeDisposable\n\n    @subscriptions.add @addDisposableEventListener this, 'click', (e) =>\n      # ...\n\n# It creates the custom element and register it as the `dummy-node` tag.\nDummyNode = document.registerElement 'dummy-node', prototype: DummyNode.prototype\n```\n\n### EventsDelegation\n\nA mixin that provides events delegation ala jQuery without jQuery.\nUse it by including it into your custom element:\n\n```coffee\n{EventsDelegation} = require 'atom-utils'\n{CompositeDisposable} = require 'event-kit'\n\nclass DummyNode extends HTMLElement\n  # It includes the mixin on the class prototype.\n  EventsDelegation.includeInto(this)\n\n  # Custom element's callback on creation.\n  createdCallback: ->\n    @subscriptions = new CompositeDisposable\n\n    @appendChild(document.createElement('div'))\n    @firstChild.appendChild(document.createElement('span'))\n\n    # Without a target and a selector, it registers to the event on the\n    # element itself.\n    # The `subscribeTo` method returns a disposable that unsubscribe from\n    # all the events that was added by this call.\n    @subscriptions.add @subscribeTo\n      click: (e) ->\n        console.log(\"won't be called if the click is done on the child div\")\n\n    # With just a selector, it registers to the event on the elements children\n    # matching the passed-in selector.\n    @subscriptions.add @subscribeTo 'div',\n      click: (e) ->\n        console.log(\"won't be called if the click is done on the child span\")\n        # Events propagation can be used to prevents the delegated handlers\n        # to catch the events in continuation.\n        e.stopPropagation()\n\n    # By passing a node and a selector, it registers to the event on the\n    # elements children matching the passed-in selector.\n    @subscriptions.add @subscribeTo @firstChild, 'span',\n      click: (e) ->\n        e.stopPropagation()\n\n# It creates the custom element and register it as the `dummy-node` tag.\nDummyNode = document.registerElement 'dummy-node', prototype: DummyNode.prototype\n```\n\n### ResizeDetection\n\nAs there is no standard way to detect when an element size changed this mixin provides a DOM polling mechanism to custom element whose display and logic may rely on the element size:\n\n```coffee\n{ResizeDetection} = require 'atom-utils'\n\nclass DummyNode extends HTMLElement\n  ResizeDetection.includeInto(this)\n\n  # Starts the DOM poll when the element is attached\n  attachedCallback: -> @initializeDOMPolling()\n\n  # Stops the DOM poll when the element is detached\n  detachedCallback: -> @disposeDOMPolling()\n\n  # Callback called when the poll routine has detected a size change.\n  # The callback receive the new width and height as arguments.\n  resizeDetected: (width, height) ->\n\n  # If you need to prevent the poll routine to check the element size,\n  # redefine this method with your own conditions. The function should return\n  # false when the polling can occurs.\n  # isDOMPollingPrevented: -> @domPollingPaused\n```\n\nIf you need to suspend the polling while keeping the interval active you can use the `pauseDOMPolling` to pause the polling routine and `resumeDOMPolling` to resume it.\n\n### SpacePenDSL\n\nA mixin that provides the same content creation mechanism as `space-pen` but for custom elements:\n\n```coffee\n{SpacePenDSL} = require 'atom-utils'\n\nclass DummyNode extends HTMLElement\n  SpacePenDSL.includeInto(this)\n\n  @content: ->\n    @div outlet: 'container', class: 'container', =>\n      @span outlet: 'label', class: 'label'\n\n  createdCallback: ->\n    # Content is available in the created callback\n\n# It creates the custom element and register it as the `dummy-node` tag.\nDummyNode = document.registerElement 'dummy-node', prototype: DummyNode.prototype\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/abe33/atom-utils.git"
  },
  "scripts": {},
  "version": "0.9.2"
}
